% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter.R
\name{filter.poparray}
\alias{filter.poparray}
\title{Filter a \code{poparray} array/cube by restricting dimension labels}
\usage{
\method{filter}{poparray}(.data, ..., .strict = TRUE)
}
\arguments{
\item{.data}{A \code{poparray} object.}

\item{...}{One or more filtering expressions. Each expression must constrain a single dimension name using supported
operators (see Details).}

\item{.strict}{Logical. If \code{TRUE} (default), unknown categorical labels are an error. If \code{FALSE}, unknown categorical
labels are dropped with a warning.}
}
\value{
A delayed \code{poparray} (or \code{tarr_pop_view}) with updated dimension restrictions. No materialization occurs.
}
\description{
\code{filter.poparray()} restricts a \code{poparray} object along one or more named dimensions using \strong{label-based
predicates}, returning a delayed \code{poparray} (or view) without materializing the data.

This is \strong{not} row filtering. It is \strong{dimension slicing} intended for
HDF5/DelayedArray-backed population cubes.
}
\details{
\subsection{What this method does \code{filter()} for \code{poparray} builds or updates a subset plan that restricts dimension}{

labels (e.g., years, counties, ages). The returned object remains delayed; realization happens later via \code{collect()},
\code{as.data.frame()}, \code{as_tibble()}, or similar.
}

\subsection{Supported predicate forms Each filter expression must reference \strong{exactly one} dimension name on the left-hand}{

side.

\strong{Categorical dimensions} (e.g. \code{area.name}, \code{sex}, \code{race}, \code{ethnicity})
support:
\itemize{
\item Equality: \code{dim == value}
\item Membership: \code{dim \%in\% values}
\item Within-dimension boolean combinations: \code{&} and \code{|} are allowed only when
both sides constrain the \emph{same} dimension.
}

\strong{Ordered dimensions} (e.g. \code{year}, \code{age.char}) additionally support:
\itemize{
\item Comparisons: \code{<}, \code{<=}, \code{>}, \code{>=}
\item Ranges: \verb{\%between\%} (if provided by the package)
}
}

\subsection{Age interval semantics (\code{age.char}) Range filtering on \code{age.char} operates on \strong{age intervals}. Labels are}{

interpreted as half-open intervals, e.g.:
\itemize{
\item \code{"37"}  → \verb{[37, 38)}
\item \code{"5-9"} → \verb{[5, 10)}
\item \code{"85+"} → \verb{[85, Inf)}
}

Range predicates (comparisons and \verb{\%between\%}) select age labels whose intervals \strong{overlap} the requested age set.
Discrete membership with \code{\%in\%} remains \strong{exact label matching} (no interval overlap).
}

\subsection{What is not supported}{
\itemize{
\item \strong{Named "short form" arguments} such as \code{filter(x, year = 2020)} are not
supported and will warn and then error. Use \code{year == 2020} or \code{year \%in\% 2015:2020}.
\item Predicates that do not map to a single dimension (e.g. \code{value > 0},
\code{year + 1 == 2021}, \code{paste(area.name) == "Tarrant"}).
\item Cross-dimension boolean logic within a single expression
(e.g. \code{year == 2020 | area.name == "Tarrant"}).
}
}

\subsection{Unknown labels and strictness}{

By default this method uses \strong{strict} label matching for categorical dimensions. If
requested labels are not present, an error is thrown (often with suggested close matches). For ordered dimensions,
errors are raised if coercion to the comparison scale fails (e.g., non-numeric year labels).
}
}
